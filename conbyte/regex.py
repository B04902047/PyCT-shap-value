
import re
import sys
import logging
from io import StringIO

"""
OPCODES:
    FAILURE SUCCESS

    ANY ANY_ALL
    ASSERT ASSERT_NOT
    AT
    BRANCH
    CALL
    CATEGORY
    CHARSET BIGCHARSET
    GROUPREF GROUPREF_EXISTS
    IN
    INFO
    JUMP
    LITERAL
    MARK
    MAX_UNTIL
    MIN_UNTIL
    NOT_LITERAL
    NEGATE
    RANGE
    REPEAT
    REPEAT_ONE
    SUBPATTERN
    MIN_REPEAT_ONE

    GROUPREF_IGNORE
    IN_IGNORE
    LITERAL_IGNORE
    NOT_LITERAL_IGNORE

    GROUPREF_LOC_IGNORE
    IN_LOC_IGNORE
    LITERAL_LOC_IGNORE
    NOT_LITERAL_LOC_IGNORE

    GROUPREF_UNI_IGNORE
    IN_UNI_IGNORE
    LITERAL_UNI_IGNORE
    NOT_LITERAL_UNI_IGNORE
    RANGE_UNI_IGNORE

    MIN_REPEAT MAX_REPEAT
"""
"""
Categories:
    \d CATEGORY_DIGIT 
    \D CATEGORY_NOT_DIGIT
    \s CATEGORY_SPACE 
    \S CATEGORY_NOT_SPACE
    \w CATEGORY_WORD 
    \W CATEGORY_NOT_WORD
    CATEGORY_LINEBREAK CATEGORY_NOT_LINEBREAK

    CATEGORY_LOC_WORD CATEGORY_LOC_NOT_WORD

    \d CATEGORY_UNI_DIGIT 
    \D CATEGORY_UNI_NOT_DIGIT
    \s CATEGORY_UNI_SPACE 
    \S CATEGORY_UNI_NOT_SPACE
    \w CATEGORY_UNI_WORD 
    \W CATEGORY_UNI_NOT_WORD
    CATEGORY_UNI_LINEBREAK 
    CATEGORY_UNI_NOT_LINEBREAK
"""

log = logging.getLogger("ct.regex")

class ReNode:
    def __init__(self, statement=None):
        self.statement = statement
        self.child = []

    def __str__(self):
        if len(self.child) != 0:
            return "(%s: %s)" % (self.statement, ",".join(val.__str__() for val in self.child))
        else:
            return "(%s)" % self.statement

class Regex:
    def __init__(self):
        # pattern object generated by re.compile
        self.pattern_value = None
        # smt expression of pattern
        self.pattern = None

    def compile(self, pattern, flags=None): 
        if flags is not None:
            flags = flags | re.DEBUG
        else:
            flags = re.DEBUG

        # Capture the debug meg 
        old_stdout = sys.stdout
        result = StringIO()
        sys.stdout = result

        self.pattern_value = re.compile(pattern.value, flags)

        sys.stdout = old_stdout
        self._compile(result.getvalue())

        return self

    def _gen_pattern(self, pattern_st, as_union=False):
        expressions = []
        literal = None 
        branch_re = None
        or_re = None
        for node in pattern_st:
            statement = node.statement
            op = statement.lstrip(' ').split(" ", 1)[0]

            # Handle literal first
            if op != "LITERAL":
                if literal is not None:
                    expressions.append("(str.to.re \"%s\")" % literal)
                    literal = None

            if op == "FAILURE":
                # TODO
                log.warning("Regex %s Not implemented" % op)

            elif op == "SUCCESS":
                # TODO
                log.warning("Regex %s Not implemented" % op)
                
            elif op == "ANY":
                # TODO: Should be discarding '\n'
                expr = "re.allchar"
                expressions.append(expr)

            elif op == "BRANCH":
                branch_re = self._gen_pattern(node.child)

            elif op == "OR":
                or_re = self._gen_pattern(node.child)
                expressions.append("(re.union %s %s)" % (branch_re, or_re))
                branch_re = None
                or_re = None

            elif op == "IN":
                inner = self._gen_pattern(node.child, True)
                expressions.append(inner)

            elif op == "LITERAL":
                char = statement.split(" ")[1]
                if as_union:
                    expressions.append("(str.to.re \"%s\")" % chr(int(char)))
                else:
                    if literal is None:
                        literal = chr(int(char))
                    else:
                        literal += chr(int(char))

            elif op == "RANGE":
                var = statement.split(" ", 1)[1].replace("(", "").replace(")", "")
                low, high = var.split(", ")
                expr = "(re.range \"%s\" \"%s\")" % (chr(int(low)), chr(int(high)))
                expressions.append(expr)

            elif op == "SUBPATTERN":
                # TODO
                inner = self._gen_pattern(node.child)
                expressions.append(inner)

            elif op == "CATEGORY":
                category = statement.split(" ")[1]
                if category == "CATEGORY_DIGIT":
                    expr = "(re.range \"0\" \"9\")"
                elif category == "CATEGORY_NOT_DIGIT":
                    # Before '0'(\x30)
                    expr0 = "(re.range \"\\x00\" \"\\x2f\")"
                    # After '9'(\x39), before end(\xff)
                    expr1 = "(re.range \"\\x3a\" \"\\xff\")"
                    expr = "(re.union %s %s)" % (expr0, expr1)
                elif category == "CATEGORY_SPACE":
                    expr = "(re.range \"\\t\" \"\\r\")"
                elif category == "CATEGORY_NOT_SPACE":
                    # Before '\t'(\x30)
                    expr0 = "(re.range \"\\x00\" \"\\x09\")"
                    # After '\r'(\x0d), before end(\xff)
                    expr1 = "(re.range \"\\x0d\" \"\\xff\")"
                    expr = "(re.union %s %s)" % (expr0, expr1)
                elif category == "CATEGORY_WORD":
                    exprd = "(re.range \"0\" \"9\")"
                    expra = "(re.range \"a\" \"z\")"
                    exprA = "(re.range \"A\" \"Z\")"
                    expr = "(re.union %s (re.union %s %s))" % (exprd, expra, exprA)
                elif category == "CATEGORY_NOT_WORD":
                    # Before '0'(\x30)
                    expr0 = "(re.range \"\\x00\" \"\\x2f\")"
                    # After '9'(\x39), before 'A'(\x41)
                    expr1 = "(re.range \"\\x3a\" \"\\x40\")"
                    # After 'Z'(\x5a), before 'a'(\x61)
                    expr2 = "(re.range \"\\x5b\" \"\\x60\")"
                    # After 'z'(\x7a), before end(\xff)
                    expr3 = "(re.range \"\\x7a\" \"\\xff\")"
                    expr = "(re.union (re.union %s %s) (re.union %s %s))" % (expr0, expr1, expr2, expr3)
                else:
                    print("Not handling CATEGORY with: %s" % category)
                    exit()
                expressions.append(expr)

            elif op == "MAX_REPEAT" or op == "MIN_REPEAT" :
                # TODO: I assume they are the same
                _, start, end = statement.split(" ")
                inner = self._gen_pattern(node.child)
                if not start.isdigit():
                    print("Not handling REPEAT with: %s" % start)
                    exit(1)
                else:
                    start = int(start)
                if end == "MAXREPEAT":
                    if start == 0:
                        expr = "(re.* %s)" % inner
                    elif start == 1:
                        expr = "(re.+ %s)" % inner
                    else:
                        expr = "(re.loop %s %s %s)" % (inner, start, MAXREPEAT)
                else:
                    expr = "(re.loop %s %s %s)" % (inner, start, end)
                expressions.append(expr)

            else:
                # TODO
                log.warning("Regex %s Not implemented" % op)

        if literal is not None:
            expressions.append("(str.to.re \"%s\")" % literal)

        if len(expressions) == 0:
            return None
        elif len(expressions) == 1:
            return expressions[0]
        else:
            if as_union:
                if len(expressions) == 2: 
                    return "(re.union " + " ".join(expr for expr in expressions) + ")"
                else:
                    expr = "(re.union %s %s)" % (expressions[0], expressions[1])
                    i = 2
                    while i < len(expressions):
                        expr = "(re.union %s %s)" % (expr, expressions[i])
                        i += 1
                    return expr
            else:
                return "(re.++ " + " ".join(expr for expr in expressions) + ")"
    
    def _parse_block(self, lines, line_no, leading_space):
        statements = []
        while line_no < len(lines):
            line = lines[line_no]
            leading = len(line) - len(line.lstrip(' '))
            if leading == leading_space:
                node = ReNode(line.lstrip(' '))
                statements.append(node)
                line_no += 1
            elif leading < leading_space:
                return statements, line_no
            else:
                st, line_no = self._parse_block(lines, line_no, leading)
                statements[-1].child = st
        return statements, line_no

    def _compile(self, raw):
        lines = []
        # Discard the 2nd part of DEBUG meg
        for line in raw.splitlines():
            if len(line) == 0:
                break
            else:
                lines.append(line)
                log.debug("Debug:   %s" % line)

        pattern_st, _ = self._parse_block(lines, 0, 0)
        self.pattern = self._gen_pattern(pattern_st)
        log.debug("Compiled: %s" % self.pattern)


    def __str__(self):
        return "{Regex, re_expr: %s)" % self.pattern
